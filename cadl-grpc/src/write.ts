import {
  ProtoEnumDeclaration,
  ProtoFieldDeclaration,
  matchType,
  ProtoMessageDeclaration,
  ProtoOneOfDeclaration,
  ProtoMethodDeclaration,
  ProtoDeclaration,
  ProtoFile,
  ProtoType,
  ProtoServiceDeclaration,
} from "./proto.js";

// This module defines how to emit the text representation of a ProtoFile AST.

export const PROTO_HEADER =
  '/* Generated by Microsoft CADL - Canonical API Definition Language */\n\nsyntax = "proto3";\n';

export function writeProtoFile(file: ProtoFile): string {
  let result = PROTO_HEADER;

  if (file.package) result += `\npackage ${file.package};\n`;

  const opts = Object.entries(file.options);
  for (const [name, valueData] of opts) {
    const value =
      typeof valueData === "string" ? `"${valueData}"` : valueData.toString();
    result += `\noption (${name}) = ${value}`;
  }

  // Give the declarations a little breathing room if options were provided
  if (opts.length > 0) result += "\n";

  for (const decl of file.declarations) {
    result += "\n" + collect(writeDeclaration(decl)).join("\n") + "\n";
  }

  return result;
}

function* writeDeclaration(decl: ProtoDeclaration): Iterable<string> {
  switch (decl.kind) {
    case "message":
      yield* writeMessage(decl);
      return;
    case "service":
      yield* writeService(decl);
      return;
    case "field":
      yield writeField(decl);
      return;
    case "oneof":
      yield* writeOneOf(decl);
      return;
    case "enum":
      yield* writeEnum(decl);
      return;
    case "method":
      yield writeMethod(decl);
      return;
    default:
      const __exhaust: never = decl;
      throw __exhaust;
  }
}

function* writeMessage(decl: ProtoMessageDeclaration): Iterable<string> {
  const head = `message ${decl.name} {`;
  const tail = "}";

  if (decl.declarations.length > 0 || decl.reservations?.length) {
    const [reservedNumbers, reservedNames] = selectMap(
      decl.reservations ?? [],
      (v) => typeof v === "number" || Array.isArray(v),
      (v) => (Array.isArray(v) ? v[0] + " to " + v[1] : v.toString()),
      (v) => `"${v.toString()}"`
    );
    yield head;
    if (reservedNumbers.length + reservedNames.length > 0) {
      if (reservedNumbers.length > 0)
        yield `  reserved ${reservedNumbers.join(", ")};`;
      if (reservedNames.length > 0)
        yield `  reserved ${reservedNames.join(", ")};`;
      yield "";
    }
    yield* indent(flatMap(decl.declarations, writeDeclaration));
    yield tail;
  } else yield head + tail;
}

function* writeService(decl: ProtoServiceDeclaration): Iterable<string> {
  const head = `service ${decl.name} {`;
  const tail = "}";

  if (decl.operations.length > 0) {
    yield head;
    yield* indent(flatMap(decl.operations, writeMethod));
    yield tail;
  } else yield head + tail;
}

function writeMethod(decl: ProtoMethodDeclaration): string {
  return `rpc ${decl.name}(${writeType(decl.input)}) returns (${writeType(
    decl.returns
  )});`;
}

function* writeOneOf(decl: ProtoOneOfDeclaration): Iterable<string> {
  // OneOf declarations must have at least one element, so no need to check for declarations
  yield `oneof ${decl.name} {`;
  yield* indent(flatMap(decl.declarations, writeDeclaration));
  yield "}";
}

function* writeEnum(decl: ProtoEnumDeclaration): Iterable<string> {
  yield `enum ${decl.name} {`;
  yield* indent(flatMap(decl.variants, ([name, idx]) => `${name} = ${idx};`));
  yield "}";
}

function writeField(decl: ProtoFieldDeclaration): string {
  const prefix = decl.repeated ? "repeated " : "";
  return prefix + `${writeType(decl.type)} ${decl.name} = ${decl.index};`;
}

function writeType(type: ProtoType): string {
  return matchType(type, {
    map: (k, v) => `map<${k}, ${writeType(v)}>`,
    ref: (r) => r,
    scalar: (s) => s,
  });
}

// #region utils

function* indent(it: Iterable<string>, depth: number = 2): Iterable<string> {
  for (const value of it) {
    yield " ".repeat(depth) + value;
  }
}

function* flatMap<T1, T2>(
  it: Iterable<T1>,
  f: (v: T1) => T2 | Iterable<T2>
): Iterable<T2> {
  for (const value of it) {
    const result = f(value);
    if (
      typeof result === "object" &&
      result !== null &&
      Symbol.iterator in result
    ) {
      yield* result as Iterable<T2>;
    } else {
      yield result as T2;
    }
  }
}

function collect<T>(it: Iterable<T>): T[] {
  const result = [];

  for (const value of it) result.push(value);

  return result;
}

function selectMap<TIn, T1, T2>(
  source: Iterable<TIn>,
  select: (v: TIn) => boolean,
  f1: (v: TIn) => T1,
  f2: (v: TIn) => T2
): [T1[], T2[]] {
  const result: [T1[], T2[]] = [[], []];
  for (const value of source) {
    if (select(value)) {
      result[0].push(f1(value));
    } else {
      result[1].push(f2(value));
    }
  }

  return result;
}

// #endregion
